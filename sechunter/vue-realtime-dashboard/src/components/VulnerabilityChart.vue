<template>
  <div>
    <canvas ref="chartCanvas"></canvas>
  </div>
</template>

<script>
import { ref, onMounted, onBeforeUnmount, nextTick } from 'vue';
import { Chart, LineController, LineElement, PointElement, LinearScale, Title, CategoryScale } from 'chart.js';
import { MockDataProvider } from '../services/mockDataProvider';

Chart.register(LineController, LineElement, PointElement, LinearScale, Title, CategoryScale);

export default {
  props: ['token'],
  setup(props) {
    const chartCanvas = ref(null);
    let chartInstance = null;
    let socket = null;

    const labels = ref([]);
    const dataPoints = ref([]);

    let lastUpdateTime = 0;
    const updateInterval = 1000; // throttle updates to 1 second

    async function updateChart(data) {
      const now = Date.now();
      if (now - lastUpdateTime < updateInterval) {
        return; // skip update if called too frequently
      }
      lastUpdateTime = now;

      if (labels.value.length > 20) {
        labels.value = labels.value.slice(1);
        dataPoints.value = dataPoints.value.slice(1);
      }
      labels.value = [...labels.value, new Date().toLocaleTimeString()];
      dataPoints.value = [...dataPoints.value, data.vulnerabilityScore];

      await nextTick();

      if (chartInstance) {
        chartInstance.data.labels = labels.value;
        chartInstance.data.datasets[0].data = dataPoints.value;
        chartInstance.update();
      }
    }

    async function fetchMockData() {
      const scores = await MockDataProvider.getVulnerabilityScores();
      for (const score of scores) {
        updateChart({ vulnerabilityScore: score });
        await new Promise(resolve => setTimeout(resolve, 500)); // simulate delay
      }
    }

    onMounted(() => {
      chartInstance = new Chart(chartCanvas.value, {
        type: 'line',
        data: {
          labels: labels.value,
          datasets: [{
            label: 'Vulnerability Score',
            data: dataPoints.value,
            borderColor: 'rgba(75, 192, 192, 1)',
            fill: false,
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          animation: false,
          interaction: {
            mode: 'nearest',
            intersect: false
          },
          plugins: {
            tooltip: {
              enabled: true,
              mode: 'index',
              intersect: false,
              callbacks: {
                label: function(context) {
                  return `Score: ${context.parsed.y}`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true
            }
          }
        }
      });

      if (process.env.VUE_APP_USE_MOCK_DATA === 'true') {
        fetchMockData();
      } else {
        function connectWebSocket() {
          socket = new WebSocket(`ws://localhost:8080/ws/vulnerabilities?token=${props.token}`);

          socket.onmessage = event => {
            const data = JSON.parse(event.data);
            updateChart(data);
          };

          socket.onopen = () => {
            console.log('WebSocket connection opened');
          };

          socket.onclose = () => {
            console.log('WebSocket connection closed, attempting to reconnect in 3 seconds...');
            setTimeout(connectWebSocket, 3000);
          };

          socket.onerror = error => {
            console.error('WebSocket error:', error);
            socket.close();
          };
        }

        connectWebSocket();
      }
    });

    onBeforeUnmount(() => {
      if (socket) {
        socket.close();
      }
      if (chartInstance) {
        chartInstance.destroy();
      }
    });

    return {
      chartCanvas
    };
  }
};
</script>

<style scoped>
canvas {
  max-width: 100%;
  height: 300px;
}
</style>
